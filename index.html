<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Space Network: Cepheus</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        #status {
            position: absolute; bottom: 30px; left: 30px;
            color: #80ff80; font-size: 14px; text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(0, 20, 0, 0.8);
            padding: 12px 20px;
            border-left: 4px solid #80ff80;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 15px rgba(128, 255, 128, 0.2);
            border-radius: 0 4px 4px 0;
        }

        /* Hover Data Card (The "Floating" Box on Hover) */
        #star-intel {
            position: absolute;
            display: none; /* Hidden until hover */
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid #7dd3ff;
            color: #e0f7ff;
            padding: 12px;
            border-radius: 4px;
            pointer-events: none; /* Mouse ignores it */
            z-index: 20;
            font-size: 12px;
            box-shadow: 0 0 15px rgba(125, 211, 255, 0.4);
            min-width: 160px;
        }
        #star-intel h3 { 
            margin: 0 0 8px 0; 
            color: #00ffff; 
            font-size: 14px; 
            border-bottom: 1px solid rgba(125, 211, 255, 0.3); 
            padding-bottom: 5px; 
            text-shadow: 0 0 5px #00ffff;
        }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .data-label { color: #88c0d0; }
        .data-val { color: #fff; font-weight: bold; }
        
        /* Permanent Star Labels (For Constellations) */
        .constellation-label {
            color: #7dd3ff;
            font-size: 11px;
            font-weight: bold;
            margin-top: -20px; 
            text-shadow: 0 0 4px #000, 0 0 2px #7dd3ff;
            pointer-events: none; 
            white-space: nowrap;
            opacity: 0.9;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="status">System Initializing...</div>
    </div>

    <div id="star-intel">
        <h3 id="intel-name">Star Name</h3>
        <div class="data-row"><span class="data-label">MAG:</span> <span id="intel-mag" class="data-val">--</span></div>
        <div class="data-row"><span class="data-label">DEC:</span> <span id="intel-dec" class="data-val">--</span></div>
        <div class="data-row"><span class="data-label">RAD:</span> <span id="intel-rad" class="data-val">--</span></div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- 1. CONFIGURATION ---
        const CONFIG = {
            earthRadius: 15,  // Bigger Earth
            skyRadius: 100,
            starCount: 2500,  // Total background stars
            colors: {
                earth: 0xaaaaaa,
                grid: 0xffffff,
                marker: 0xff3333,
                lines: 0x00ffff, // Cyan lines
            }
        };

        // Specific Constellation Data
        const CONSTELLATION_DATA = [
            {"ra":23.65582, "dec":77.632276, "mag":3.21, "name":"Errai"},
            {"ra":21.477662,"dec":70.560716, "mag":3.23, "name":"Alfirk"},
            {"ra": 332.7137,"dec": 58.2013,"mag": 3.35,"name": "Zeta Cephai"},
            {"ra":21.30963, "dec":62.585573, "mag":2.45, "name":"Alderamin"}, 
            {"ra":22.82802, "dec":66.200408, "mag":3.5,  "name":"32Iot Cep"}
        ];

        // --- 2. SCENE SETUP ---
        const scene = new THREE.Scene();
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 50); // Moved back to see bigger Earth

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // CSS2D Renderer for Labels
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none'; // CRITICAL: Lets mouse clicks pass through
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 250;

        const clock = new THREE.Clock();
        const texLoader = new THREE.TextureLoader();

        // --- 3. EARTH SYSTEM ---
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        const earthMap = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
        const starTexture = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/disc.png');

        const earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.earthRadius, 64, 64),
            new THREE.MeshBasicMaterial({
                map: earthMap,
                transparent: true, opacity: 0.9, color: CONFIG.colors.earth,
                blending: THREE.AdditiveBlending, side: THREE.FrontSide
            })
        );
        earthGroup.add(earthMesh);

        const earthGrid = new THREE.LineSegments(
            new THREE.WireframeGeometry(new THREE.SphereGeometry(CONFIG.earthRadius + 0.1, 24, 24)),
            new THREE.LineBasicMaterial({ color: CONFIG.colors.grid, transparent: true, opacity: 0.15 })
        );
        earthGroup.add(earthGrid);

        const userMarker = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshBasicMaterial({ color: CONFIG.colors.marker })
        );
        userMarker.visible = false;
        earthGroup.add(userMarker);

        const sun = new THREE.DirectionalLight(0xffffff, 0.75);
        sun.position.set(7, 6, 8);
        scene.add(sun);

        // --- 4. DATA & UTILS ---
        
        function getStarPosition(raHours, decDeg, radius) {
            const phi = (90 - decDeg) * (Math.PI / 180);
            const theta = (raHours * 15) * (Math.PI / 180); 
            return new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // Logic to generate the "RadZZMagXXDecYY" string
        function generateProceduralName(pos, mag) {
            const r = Math.round(pos.length()).toString();
            const m = (mag * 10).toFixed(0).toString(); // Multiplying to get digits
            
            // Calculate Dec from position for accuracy
            // y = r * cos(phi) -> phi = acos(y/r) -> dec = 90 - phi_deg
            const rVal = pos.length();
            const phi = Math.acos(pos.y / rVal);
            const decDeg = Math.abs(90 - (phi * 180 / Math.PI));
            const d = Math.round(decDeg).toString();

            // Safe slice to get first 2 digits (pad with 0 if single digit)
            const radZZ = r.padStart(2, '0').substring(0, 2);
            const magXX = m.padStart(2, '0').substring(0, 2);
            const decYY = d.padStart(2, '0').substring(0, 2);

            return `Rad${radZZ}Mag${magXX}Dec${decYY}`;
        }

        // --- 5. STAR GENERATION ---
        
        // We will store ALL stars (background + constellation) in a single array for Raycasting
        const allStarData = []; 
        const constellationPathPoints = [];

        // Arrays for BufferGeometry
        const geoPositions = [];
        const geoSizes = [];
        const geoAlphas = [];

        // 5a. Constellation Stars (ALWAYS VISIBLE LABELS)
        CONSTELLATION_DATA.forEach((star) => {
            const pos = getStarPosition(star.ra, star.dec, CONFIG.skyRadius);
            
            constellationPathPoints.push(pos);
            geoPositions.push(pos.x, pos.y, pos.z);
            
            // Visuals: Bigger, brighter
            const size = Math.max(5.0, 8.0 - star.mag); 
            geoSizes.push(size);
            geoAlphas.push(1.0);

            // Add to Interaction Data
            allStarData.push({
                position: pos.clone(),
                name: star.name, // Explicit Name
                mag: star.mag,
                dec: star.dec.toFixed(1),
                rad: CONFIG.skyRadius.toFixed(0)
            });

            // PERMANENT LABEL (Floating Text)
            const div = document.createElement('div');
            div.className = 'constellation-label';
            div.textContent = star.name;
            const label = new CSS2DObject(div);
            label.position.copy(pos);
            scene.add(label);
        });

        // 5b. Background Stars (PROCEDURAL NAMES)
        for (let i = 0; i < CONFIG.starCount; i++) {
            // Random spherical coordinates
            const r = CONFIG.skyRadius * (0.85 + Math.random() * 0.3); // Vary radius (85-115)
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            const pos = new THREE.Vector3(x, y, z);

            geoPositions.push(x, y, z);
            
            const mag = Math.random() * 6;
            const size = Math.random() * 2.0 + 0.5;
            geoSizes.push(size);
            geoAlphas.push(Math.random() * 0.6 + 0.1);

            // Add to Interaction Data (Only if bright enough to be worth clicking)
            // Or add all of them if you want full interaction
            if (size > 1.0) {
                allStarData.push({
                    position: pos,
                    name: null, // No database name -> triggers procedural logic
                    mag: mag,
                    dec: null, // Will calc on fly
                    rad: r
                });
            }
        }

        // 5c. Build Geometry
        const starGeometry = new THREE.BufferGeometry();
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(geoPositions, 3));
        starGeometry.setAttribute('aBaseSize', new THREE.Float32BufferAttribute(geoSizes, 1));
        starGeometry.setAttribute('aAlpha', new THREE.Float32BufferAttribute(geoAlphas, 1));

        const starMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 }, pointTexture: { value: starTexture } },
            vertexShader: `
                attribute float aBaseSize; attribute float aAlpha; varying float vAlpha;
                void main() {
                    vAlpha = aAlpha;
                    vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = aBaseSize * (300.0 / -mvPos.z);
                    gl_Position = projectionMatrix * mvPos;
                }
            `,
            fragmentShader: `
                uniform float time; uniform sampler2D pointTexture; varying float vAlpha;
                void main() {
                    vec4 color = texture2D(pointTexture, gl_PointCoord);
                    if (color.a < 0.5) discard;
                    float twinkle = 0.8 + 0.2 * sin(time * 5.0 + gl_FragCoord.x);
                    gl_FragColor = vec4(vec3(1.0), vAlpha * color.a * twinkle);
                }
            `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });

        const starSystem = new THREE.Points(starGeometry, starMaterial);
        scene.add(starSystem);

        // 5d. Constellation Tube (CLOSED LOOP)
        // 'true' as 2nd arg -> closes the curve
        const path = new THREE.CatmullRomCurve3(constellationPathPoints, true);
        const tubeGeometry = new THREE.TubeGeometry(path, 64, 0.25, 8, true);
        const tubeMaterial = new THREE.MeshBasicMaterial({ 
            color: CONFIG.colors.lines, transparent: true, opacity: 0.9 
        });
        const constellationLines = new THREE.Mesh(tubeGeometry, tubeMaterial);
        scene.add(constellationLines);


        // --- 6. INTERACTION (RAYCASTER) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // UI Elements
        const intelCard = document.getElementById('star-intel');
        const elName = document.getElementById('intel-name');
        const elMag = document.getElementById('intel-mag');
        const elDec = document.getElementById('intel-dec');
        const elRad = document.getElementById('intel-rad');

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Move tooltip near mouse
            intelCard.style.left = (event.clientX + 20) + 'px';
            intelCard.style.top = (event.clientY + 20) + 'px';
        });

        // --- 7. ANIMATION STATE ---
        let state = { locating: true, rotatingToUser: false, targetY: 0 };
        const STATUS = document.getElementById('status');

        function updateLocation(lat, lon) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180); 
            
            const x = -(CONFIG.earthRadius * Math.sin(phi) * Math.cos(theta));
            const z = (CONFIG.earthRadius * Math.sin(phi) * Math.sin(theta));
            const y = (CONFIG.earthRadius * Math.cos(phi));
            
            userMarker.position.set(x, y, z);
            userMarker.visible = true;

            // Target Y Rotation to center user
            state.targetY = -(lon * Math.PI / 180) - (Math.PI / 2);
            state.locating = false;
            state.rotatingToUser = true;
            STATUS.textContent = `Coordinates Locked: ${lat.toFixed(2)}, ${lon.toFixed(2)}`;
            STATUS.style.borderLeftColor = "#00ffff"; 
        }

        // Get Location
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (p) => updateLocation(p.coords.latitude, p.coords.longitude),
                (e) => {
                    STATUS.textContent = "GPS Denied. Defaulting to Asia Sector.";
                    setTimeout(() => updateLocation(20.59, 78.96), 1500);
                }
            );
        } else {
            setTimeout(() => updateLocation(20.59, 78.96), 1500);
        }


        // GLOBAL VARIABLES FOR RAYCASTING (Place these right before animate)
        const tempV = new THREE.Vector3();
        const raycaster = new THREE.Raycaster(); // Keep just in case needed for other things
        
        function animate() {
            requestAnimationFrame(animate);
            const elapsed = clock.getElapsedTime();
            starMaterial.uniforms.time.value = elapsed;

            // --- 1. STAR HOVER LOGIC (Screen Space) ---
            // This method works perfectly even when zoomed in!
            
            let closestStar = null;
            let minDist = 15; // Pixel distance tolerance (Hitbox size)

            // Only check if we aren't in the "Locating" fast-spin mode
            if (!state.locating) {
                
                // We use a classic loop for performance
                for (let i = 0; i < allStarData.length; i++) {
                    const star = allStarData[i];
                    
                    // 1. Get 3D position
                    tempV.copy(star.position);
                    
                    // 2. Project to 2D Screen Space
                    // (Standard Three.js math to go from 3D world -> 2D screen)
                    tempV.project(camera);

                    // 3. Check if star is in front of camera (z < 1)
                    if (tempV.z < 1) {
                        // Convert normalized coordinates (-1 to +1) to pixel coordinates
                        const x = (tempV.x * .5 + .5) * window.innerWidth;
                        const y = -(tempV.y * .5 - .5) * window.innerHeight;

                        // Calculate distance from mouse pointer
                        // Mouse pointer needs to be converted to pixels too!
                        const mousePixelX = (mouse.x * .5 + .5) * window.innerWidth;
                        const mousePixelY = -(mouse.y * .5 - .5) * window.innerHeight;

                        const dx = x - mousePixelX;
                        const dy = y - mousePixelY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < minDist) {
                            closestStar = star;
                            break; // Stop looking, we found one!
                        }
                    }
                }
            }

            // --- 2. UPDATE UI BASED ON HOVER ---
            if (closestStar) {
                intelCard.style.display = 'block';
                document.body.style.cursor = 'crosshair';

                // Case A: Named Star from Database
                if (closestStar.name) {
                    elName.textContent = closestStar.name;
                    elName.style.color = "#00ffff"; // Cyan
                    elMag.textContent = closestStar.mag;
                    elDec.textContent = closestStar.dec;
                    elRad.textContent = closestStar.rad;
                } 
                // Case B: Procedural Star (The "RadZZ..." format)
                else {
                    const procName = generateProceduralName(closestStar.position, closestStar.mag);
                    elName.textContent = procName;
                    elName.style.color = "#ffcc00"; // Gold
                    
                    // Generate rough data for display
                    elMag.textContent = closestStar.mag.toFixed(2);
                    const rVal = closestStar.position.length();
                    const phi = Math.acos(closestStar.position.y / rVal);
                    const decDeg = Math.abs(90 - (phi * 180 / Math.PI));
                    
                    elDec.textContent = decDeg.toFixed(1);
                    elRad.textContent = rVal.toFixed(1);
                }
            } else {
                intelCard.style.display = 'none';
                document.body.style.cursor = 'default';
            }

            // --- 3. EARTH ANIMATION ---
            if (state.locating) {
                earthGroup.rotation.y += 0.05;
            } else if (state.rotatingToUser) {
                let currentY = earthGroup.rotation.y;
                let diff = state.targetY - currentY;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                earthGroup.rotation.y += diff * 0.05;
                if (Math.abs(diff) < 0.001) state.rotatingToUser = false;
            } else {
                earthGroup.rotation.y += 0.0003;
            }

            starSystem.rotation.y -= 0.0001;
            constellationLines.rotation.y -= 0.0001;

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

            // --- Earth Animation (Unchanged) ---
            if (state.locating) {
                earthGroup.rotation.y += 0.05;
            } else if (state.rotatingToUser) {
                let currentY = earthGroup.rotation.y;
                let diff = state.targetY - currentY;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                earthGroup.rotation.y += diff * 0.05;
                if (Math.abs(diff) < 0.001) state.rotatingToUser = false;
            } else {
                earthGroup.rotation.y += 0.0003; 
            }

            starSystem.rotation.y -= 0.0001;
            constellationLines.rotation.y -= 0.0001;

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

            // --- Earth Animation ---
            if (state.locating) {
                earthGroup.rotation.y += 0.05;
            } else if (state.rotatingToUser) {
                let currentY = earthGroup.rotation.y;
                let diff = state.targetY - currentY;
                
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;

                earthGroup.rotation.y += diff * 0.05;
                
                if (Math.abs(diff) < 0.001) {
                    state.rotatingToUser = false;
                }
            } else {
                earthGroup.rotation.y += 0.0003; // Slow spin
            }

            // Parallax
            starSystem.rotation.y -= 0.0001;
            constellationLines.rotation.y -= 0.0001;

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
