<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celestial Earth Visualization</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #status {
            position: absolute; bottom: 20px; left: 20px;
            color: #80ff80; font-family: monospace; font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="status">Initializing system...</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- CONFIGURATION ---
    const EARTH_R = 5;
    const STAR_COUNT = 3000; // Generated stars since raw data wasn't provided
    const CEPHEUS_LINE_COLOR = 0x7dd3ff;
    const OTHER_LINE_COLOR = 0x88c0d0;

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    const clock = new THREE.Clock();
    const STATUS = document.getElementById('status');

    // --- TEXTURE LOADER ---
    const texLoader = new THREE.TextureLoader();
    // Using a basic dot for stars to avoid CORS issues with external sprites
    const dotTexture = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/disc.png');
    const earthMap = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');

    // --- EARTH GROUP ---
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    // 1. The Earth (Your requested style)
    const earthMat = new THREE.MeshBasicMaterial({
        map: earthMap,
        transparent: true,
        opacity: 0.9,
        color: 0xaaaaaa,
        blending: THREE.AdditiveBlending,
        side: THREE.FrontSide
    });
    const earthMesh = new THREE.Mesh(new THREE.SphereGeometry(EARTH_R, 64, 64), earthMat);
    earthGroup.add(earthMesh);

    // 2. The Grid (Your requested style)
    const grid = new THREE.LineSegments(
        new THREE.WireframeGeometry(new THREE.SphereGeometry(EARTH_R + 0.1, 24, 24)),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 })
    );
    earthGroup.add(grid);

    // 3. User Marker (Cleaned up - single instance)
    const userMarker = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0x80ff80 })
    );
    userMarker.visible = false; // Hidden until location found
    earthGroup.add(userMarker);

    // --- LIGHTING ---
    const dir = new THREE.DirectionalLight(0xffffff, 0.75);
    dir.position.set(7, 6, 8);
    scene.add(dir);

    // --- STAR SYSTEM (Shader Based) ---
    // Generating dummy star data since original arrays were not provided
    const starPositions = [];
    const magnitudes = [];
    for(let i=0; i<STAR_COUNT; i++) {
        const r = 50 + Math.random() * 50; // Distance from center
        const theta = 2 * Math.PI * Math.random();
        const phi = Math.acos(2 * Math.random() - 1);
        starPositions.push(
            r * Math.sin(phi) * Math.cos(theta),
            r * Math.sin(phi) * Math.sin(theta),
            r * Math.cos(phi)
        );
        magnitudes.push(Math.random() * 6); // Magnitude 0 to 6
    }

    // Building Geometry
    const starGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(STAR_COUNT * 3);
    const colors = new Float32Array(STAR_COUNT * 3);
    const aBaseSize = new Float32Array(STAR_COUNT);
    const aAlpha = new Float32Array(STAR_COUNT);

    for (let i = 0; i < STAR_COUNT; i++) {
        // Positions
        positions[i*3] = starPositions[i*3];
        positions[i*3+1] = starPositions[i*3+1];
        positions[i*3+2] = starPositions[i*3+2];

        // Colors & Alpha based on Magnitude
        const mag = magnitudes[i];
        const intensity = Math.pow(10, -0.4 * mag); // Physics-based brightness
        colors[i*3] = intensity;
        colors[i*3+1] = intensity;
        colors[i*3+2] = intensity;
        
        const size = THREE.MathUtils.clamp(4.2 - mag * 0.45, 0.9, 3.2);
        const alpha = THREE.MathUtils.clamp(1.0 - (mag + 1.2) * 0.12, 0.25, 1.0);
        
        aBaseSize[i] = size;
        aAlpha[i] = alpha;
    }

    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    starGeo.setAttribute('aBaseSize', new THREE.BufferAttribute(aBaseSize, 1));
    starGeo.setAttribute('aAlpha', new THREE.BufferAttribute(aAlpha, 1));

    const starMaterial = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointTexture: { value: dotTexture }
        },
        vertexShader: `
            attribute float aBaseSize;
            attribute float aAlpha;
            varying float vAlpha;
            void main() {
                vAlpha = aAlpha;
                vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = aBaseSize * (220.0 / -mvPos.z);
                gl_Position = projectionMatrix * mvPos;
            }
        `,
        fragmentShader: `
            precision mediump float;
            varying float vAlpha;
            uniform sampler2D pointTexture;
            void main() {
                vec4 color = texture2D(pointTexture, gl_PointCoord);
                if (color.a < 0.5) discard;
                gl_FragColor = vec4(vec3(1.0), vAlpha * color.a);
            }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    const starSystem = new THREE.Points(starGeo, starMaterial);
    scene.add(starSystem);


    // --- CONSTELLATIONS (Placeholder Logic) ---
    // Note: You need actual constellation data (pairs of stars) to draw lines.
    // This group is initialized here so your logic doesn't break.
    const constellationGroup = new THREE.Group();
    scene.add(constellationGroup);


    // --- STATE MANAGEMENT ---
    let locatingUser = true;
    let userLocationFound = false;
    let rotateToUser = false;
    let targetQuat = new THREE.Quaternion();

    // Mocking a User Location find after 3 seconds
    setTimeout(() => {
        // Example: Lon 0, Lat 0 (Center of map for test)
        // Convert Lat/Lon to Vector3 on Sphere
        const lat = 20, lon = 70; // Example coords
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        
        const x = -(EARTH_R * Math.sin(phi) * Math.cos(theta));
        const z = (EARTH_R * Math.sin(phi) * Math.sin(theta));
        const y = (EARTH_R * Math.cos(phi));

        userMarker.position.set(x, y, z);
        userMarker.visible = true;
        
        // Calculate rotation needed to face user
        // Simple approach: Look at the marker from outside
        const targetPos = new THREE.Vector3(x, y, z).normalize().multiplyScalar(20);
        
        userLocationFound = true;
        locatingUser = false;
        rotateToUser = true;
        
        STATUS.textContent = "Location found. Aligning satellite view...";
    }, 3000);


    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        
        // Update Shader Time (if you add twinkling later)
        starMaterial.uniforms.time.value = clock.getElapsedTime();

        // 1. Locating Phase (Fast Spin)
        if (locatingUser) {
            earthGroup.rotation.y += 0.005; 
            STATUS.textContent = "Scanning global coordinates...";
        }

        // 2. Aligning Phase (Smooth Slerp)
        if (rotateToUser) {
            // Note: A real implementation requires calculating the target Quaternion 
            // based on the camera position. For now, we stop the spin to simulate 'lock on'.
            // To properly rotate Earth to face camera, we usually rotate the GROUP, not the camera.
            
            // Simplified "Lock" simulation:
            earthGroup.rotation.y *= 0.95; // Slow down rapidly
            if(earthGroup.rotation.y < 0.0001) {
                rotateToUser = false;
                STATUS.textContent = "Your location is pinned.";
            }
        }

        // 3. Idle Phase (Gentle Rotation)
        if (!locatingUser && !rotateToUser) {
            earthGroup.rotation.y += 0.00025;
            // Parallax effect
            starSystem.rotation.y -= 0.00005;
        }

        controls.update();
        renderer.render(scene, camera);
    }

    // --- RESIZE HANDLER ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
