<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Real Star Sky — Interactive</title>
<style>
  html,body { height:100%; margin:0; background:#000; font-family:monospace; color:#ddd; overflow:hidden; }
  #canvas-container { position:absolute; inset:0; }
  #ui {
    position: absolute; left:16px; bottom:18px; z-index: 20;
    background: rgba(0,0,0,0.25); padding:8px 10px; border-radius:8px;
    color:#dfe6ea;
  }
  .star-info {
    position: absolute;
    z-index: 40;
    background: rgba(6,8,12,0.95);
    color: #fff;
    padding: 8px 10px;
    border-radius: 8px;
    pointer-events: auto;
    font-size: 13px;
    max-width: 240px;
  }
  .label {
    color: white;
    text-shadow: 0 0 4px rgba(0,0,0,0.9);
    pointer-events: none;
    font-size: 11px;
    font-weight: 600;
  }
  #hint { font-size:12px; opacity:0.9; }
  #process-panel {
    position:absolute; right:16px; bottom:18px; z-index:25;
    min-width:240px;
    background: rgba(4,8,14,0.55);
    border: 1px solid rgba(140,180,220,0.25);
    border-radius: 10px;
    padding: 10px 12px;
    color: #d9e6f2;
    backdrop-filter: blur(4px);
  }
  #process-title { font-size: 11px; letter-spacing: 1.4px; opacity: 0.75; margin-bottom: 8px; }
  .process-line { font-size: 12px; margin: 3px 0; }
  .process-label { opacity: 0.72; margin-right: 6px; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="canvas-container"></div>
<div id="ui">
  <div><strong>REAL STAR SKY</strong></div>
  <div id="status">Loading stars…</div>
  <div id="hint">Touch a star to see details • Labels show for brightest stars</div>
</div>

<!-- Info popup placeholder -->
<div id="info-popup" class="star-info" style="display:none"></div>
<div id="process-panel">
  <div id="process-title">SYSTEM STATUS</div>
  <div class="process-line"><span class="process-label">1.</span><span id="proc-connection">Connecting to stellar map...</span></div>
  <div class="process-line"><span class="process-label">2.</span><span id="proc-location">Waiting to start geolocation...</span></div>
  <div class="process-line"><span class="process-label">3.</span><span id="proc-latlon">Latitude/Longitude: -- / --</span></div>
  <div class="process-line"><span class="process-label">4.</span><span id="proc-current">Preparing scene...</span></div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";

/* ---------- Core scene ---------- */
const container = document.getElementById('canvas-container');

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 16);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
container.appendChild(renderer.domElement);

const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(window.innerWidth, window.innerHeight);
labelRenderer.domElement.style.position = 'absolute';
labelRenderer.domElement.style.top = '0px';
labelRenderer.domElement.style.pointerEvents = 'none';
container.appendChild(labelRenderer.domElement);

/* ---------- Controls (no zoom) ---------- */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false;         // user may not zoom
controls.enablePan = false;
controls.minPolarAngle = 0.1;
controls.maxPolarAngle = Math.PI - 0.1;

/* ---------- Earth (center) ---------- */
const earthGroup = new THREE.Group();
scene.add(earthGroup);

const EARTH_R = 5;
const texLoader = new THREE.TextureLoader();
const earthMat = new THREE.MeshBasicMaterial({
  map: texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg'),
  transparent: true,
  opacity: 0.9,
  color: 0xaaaaaa,
  blending: THREE.AdditiveBlending
});
const earthMesh = new THREE.Mesh(new THREE.SphereGeometry(EARTH_R, 64, 64), earthMat);
earthGroup.add(earthMesh);

const earthGrid = new THREE.LineSegments(
  new THREE.WireframeGeometry(new THREE.SphereGeometry(EARTH_R + 0.1, 24, 24)),
  new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 })
);
earthGroup.add(earthGrid);

const userMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.15, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0x80ff80 })
);
userMarker.visible = false;
earthGroup.add(userMarker);

const userMarker = new THREE.Mesh(
  new THREE.SphereGeometry(0.15, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0x80ff80 })
);
userMarker.visible = false;
earthGroup.add(userMarker);

/* ---------- Sky group (stars live here around Earth) ---------- */
const skyGroup = new THREE.Group();
earthGroup.add(skyGroup); // keep sky tied to earth for consistent observer frame

const SKY_R = 18; // radius for star sphere (visual)

/* ---------- Utility: RA/Dec -> unit vector ---------- */
function getStarVector(raVal, dec) {
  // raVal expected in degrees (0..360). dec in degrees (-90..90).
  const ra = THREE.MathUtils.degToRad(raVal);
  const decRad = THREE.MathUtils.degToRad(dec);
  const x = Math.cos(decRad) * Math.cos(ra);
  const y = Math.sin(decRad);
  const z = Math.cos(decRad) * Math.sin(ra);
  return new THREE.Vector3(x, y, z);
}

/* ---------- Load stars JSON ---------- */
const STATUS = document.getElementById('status');
const PROCESS_CONNECTION = document.getElementById('proc-connection');
const PROCESS_LOCATION = document.getElementById('proc-location');
const PROCESS_LATLON = document.getElementById('proc-latlon');
const PROCESS_CURRENT = document.getElementById('proc-current');
let rawStars = []; // array of input star objects
let starPositions = []; // THREE.Vector3 positions scaled
let starMeta = []; // parallel metadata
let pointsMesh; // THREE.Points

let starMaterial; // ShaderMaterial

/* ---------- Constellation definitions (by star name) ---------- */
const CONSTELLATIONS = [
  {
    name: "CEPHEUS",
    lines: [
      ["Alderamin","Alfirk"], ["Alfirk","Errai"], ["Errai","Iota Cep"],
      ["Iota Cep","Zeta Cep"], ["Zeta Cep","Alderamin"]
    ]
  },
  {
    name: "ORION",
    lines: [
      ["Betelgeuse","Bellatrix"], ["Bellatrix","Rigel"], ["Rigel","Saiph"],
      ["Saiph","Alnitak"], ["Alnitak","Alnilam"], ["Alnilam","Mintaka"],
      ["Mintaka","Betelgeuse"]
    ]
  },
  {
    name: "URSA MAJOR",
    lines: [
      ["Dubhe","Merak"], ["Merak","Phecda"], ["Phecda","Megrez"],
      ["Megrez","Alioth"], ["Alioth","Mizar"], ["Mizar","Alkaid"]
    ]
  }
];

/* ---------- Helper: normalize RA units (hours vs degrees) ---------- */
function normalizeRaArray(arr) {
  // arr are numbers (may be strings). If most <= 25 -> hours
  const nums = arr.map(v => Number(v));
  const maxVal = Math.max(...nums.filter(isFinite));
  if (maxVal <= 25) {
    return nums.map(v => v * 15); // hours -> degrees
  }
  // otherwise wrap to 0..360
  return nums.map(v => ((v % 360) + 360) % 360);
}

/* ---------- Load and build stars ---------- */
fetch('./stars_3000.json').then(r => {
  if (!r.ok) throw new Error('Failed to fetch stars_3000.json: ' + r.status);
  return r.json();
}).then(data => {
  // Accept either top-level array or {stars: [...]}
  let stars = data;
  if (!Array.isArray(stars) && Array.isArray(data.stars)) stars = data.stars;
  if (!Array.isArray(stars)) throw new Error('stars_3000.json must be an array');

  rawStars = stars.map(s => {
    return {
      ra: s.ra !== undefined ? Number(s.ra) : (s.RA !== undefined ? Number(s.RA): NaN),
      dec: s.dec !== undefined ? Number(s.dec) : (s.DEC !== undefined ? Number(s.DEC): NaN),
      mag: s.mag !== undefined ? Number(s.mag) : (s.mag_vis !== undefined ? Number(s.mag_vis): 99),
      name: s.name || s.proper || s.properName || null
    };
  });

  // Normalize RA units
  const raVals = rawStars.map(s => s.ra);
  const raDegs = normalizeRaArray(raVals);
  rawStars.forEach((s, i) => s._raDeg = raDegs[i]);

  // Build positions
  starPositions = rawStars.map(s => getStarVector(s._raDeg, s.dec).multiplyScalar(SKY_R));
  starMeta = rawStars.map(s => ({ name: s.name, mag: s.mag, ra: s._raDeg, dec: s.dec }));

  buildPointCloud();
  buildConstellationLines();
  buildLabels();
  if (!locatingUser) {
    STATUS.textContent = `Loaded ${rawStars.length} stars`;
  }
}).catch(err => {
  console.error(err);
  STATUS.textContent = 'Failed to load stars_3000.json';
  PROCESS_CONNECTION.textContent = 'Stellar map connection failed';
  PROCESS_CURRENT.textContent = 'Cannot continue without star catalog';
});

/* ---------- Build points (no glow: simple brightness points) ---------- */
function buildPointCloud() {
  const N = starPositions.length;
  const positions = new Float32Array(N * 3);
  const aBaseSize = new Float32Array(N);
  const aAlpha = new Float32Array(N);

  for (let i = 0; i < N; i++) {
    const p = starPositions[i];
    positions[i*3] = p.x;
    positions[i*3+1] = p.y;
    positions[i*3+2] = p.z;

    const mag = isFinite(starMeta[i].mag) ? starMeta[i].mag : 6;
    const size = THREE.MathUtils.clamp(4.2 - mag * 0.45, 0.9, 3.2);
    const alpha = THREE.MathUtils.clamp(1.0 - (mag + 1.2) * 0.12, 0.25, 1.0);
    aBaseSize[i] = size;
    aAlpha[i] = alpha;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('aBaseSize', new THREE.BufferAttribute(aBaseSize, 1));
  geo.setAttribute('aAlpha', new THREE.BufferAttribute(aAlpha, 1));

  starMaterial = new THREE.ShaderMaterial({
    vertexShader: `
      attribute float aBaseSize;
      attribute float aAlpha;
      varying float vAlpha;
      void main(){
        vAlpha = aAlpha;
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = aBaseSize * (220.0 / -mvPos.z);
        gl_Position = projectionMatrix * mvPos;
      }
    `,
    fragmentShader: `
      precision mediump float;
      varying float vAlpha;
      void main(){
        gl_FragColor = vec4(vec3(1.0), vAlpha);
      }
    `,
    transparent: true,
    depthWrite: false
  });

  pointsMesh = new THREE.Points(geo, starMaterial);
  skyGroup.add(pointsMesh);
}

/* ---------- Build constellation lines if possible ---------- */
const constellationGroup = new THREE.Group();
skyGroup.add(constellationGroup);

const CEPHEUS_LINE_COLOR = 0x7dd3ff;
const OTHER_LINE_COLOR = 0x88c0d0;

function buildConstellationLines() {
  constellationGroup.clear();
  const starIndexByName = {};
  for (let i = 0; i < rawStars.length; i++) {
    const name = (rawStars[i].name || "").toString().trim();
    if (name) starIndexByName[name.toLowerCase()] = i;
  }

  CONSTELLATIONS.forEach(cons => {
    let used = false;
    cons.lines.forEach(pair => {
      const a = starIndexByName[pair[0].toLowerCase()];
      const b = starIndexByName[pair[1].toLowerCase()];
      if (a !== undefined && b !== undefined) {
        const pa = starPositions[a];
        const pb = starPositions[b];
        const pts = [new THREE.Vector3(pa.x, pa.y, pa.z), new THREE.Vector3(pb.x, pb.y, pb.z)];
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({
          color: cons.name === 'CEPHEUS' ? CEPHEUS_LINE_COLOR : OTHER_LINE_COLOR,
          linewidth: 1,
          transparent: true,
          opacity: cons.name === 'CEPHEUS' ? 1 : 0.7
        });
        const line = new THREE.Line(geom, mat);
        constellationGroup.add(line);
        used = true;
      }
    });
    // If any lines were used, add a centered label near centroid (optional)
    if (used) {
      // find centroid from used star names in this constellation
      const usedIdx = [];
      cons.lines.forEach(pair => {
        const a = starIndexByName[pair[0].toLowerCase()];
        const b = starIndexByName[pair[1].toLowerCase()];
        if (a !== undefined) usedIdx.push(a);
        if (b !== undefined) usedIdx.push(b);
      });
      if (usedIdx.length > 0) {
        let cx = 0, cy = 0, cz = 0;
        usedIdx.forEach(i => { cx += starPositions[i].x; cy += starPositions[i].y; cz += starPositions[i].z; });
        cx /= usedIdx.length; cy /= usedIdx.length; cz /= usedIdx.length;
        const div = document.createElement('div');
        div.className = 'label';
        div.textContent = cons.name;
        const label = new CSS2DObject(div);
        label.position.set(cx*1.02, cy*1.02, cz*1.02);
        constellationGroup.add(label);
      }
    }
  });
}

/* ---------- Labels for bright named stars ---------- */
function buildLabels() {
  // Remove previous if any
  // Add labels for stars with a name and bright
  for (let i = 0; i < rawStars.length; i++) {
    const m = rawStars[i].mag;
    const name = rawStars[i].name;
    if (!name) continue;
    // show only the brightest to avoid clutter
    if (m > 2.0) continue;
    const pos = starPositions[i].clone().multiplyScalar(1.02);
    const div = document.createElement('div');
    div.className = 'label';
    div.textContent = name;
    const label = new CSS2DObject(div);
    label.position.copy(pos);
    skyGroup.add(label);
  }
}

/* ---------- Click/touch picking (screen-projected) ---------- */
const infoPopup = document.getElementById('info-popup');

function showInfoScreen(x, y, contentHTML) {
  infoPopup.style.left = Math.min(window.innerWidth - 260, Math.max(8, x)) + 'px';
  infoPopup.style.top = Math.min(window.innerHeight - 120, Math.max(8, y)) + 'px';
  infoPopup.innerHTML = contentHTML;
  infoPopup.style.display = 'block';
}
function hideInfoScreen() {
  infoPopup.style.display = 'none';
}

function screenPosFromVector(vec) {
  // vec as world position
  const p = vec.clone().project(camera);
  return { x: (p.x * 0.5 + 0.5) * window.innerWidth, y: (-p.y * 0.5 + 0.5) * window.innerHeight, z: p.z };
}

// pointer handler
let pointerDown = false;
renderer.domElement.addEventListener('pointerdown', (ev) => {
  pointerDown = true;
  handlePointer(ev);
});
renderer.domElement.addEventListener('pointerup', () => pointerDown = false);
renderer.domElement.addEventListener('pointercancel', () => pointerDown = false);

function handlePointer(ev) {
  // find nearest star within threshold (in screen pixels)
  const threshold = 14; // touch radius
  let best = null;
  let bestDist = threshold * threshold;

  const mouseX = ev.clientX;
  const mouseY = ev.clientY;

  // iterate all stars and project (5k is OK)
  for (let i = 0; i < starPositions.length; i++) {
    const worldPos = starPositions[i].clone();
    // star positions are local to skyGroup; convert to world
    worldPos.applyMatrix4(skyGroup.matrixWorld);
    const sp = screenPosFromVector(worldPos);
    // ignore stars behind camera (z > 1 or z < -1)
    if (sp.z > 1 || sp.z < -1) continue;
    const dx = sp.x - mouseX;
    const dy = sp.y - mouseY;
    const d2 = dx*dx + dy*dy;
    if (d2 < bestDist) {
      bestDist = d2;
      best = { idx: i, screen: sp };
    }
  }

  if (best) {
    const meta = starMeta[best.idx];
    const raw = rawStars[best.idx];
    const html = `
      <div style="font-weight:700; font-size:14px; margin-bottom:6px">${meta.name || 'Unnamed Star'}</div>
      <div>RA: ${raw._raDeg !== undefined ? raw._raDeg.toFixed(4) + '°' : '—'}</div>
      <div>Dec: ${raw.dec !== undefined ? raw.dec.toFixed(4) + '°' : '—'}</div>
      <div>Mag: ${meta.mag}</div>
      <div style="margin-top:6px; font-size:12px; opacity:0.85">Index: ${best.idx}</div>
      <div style="margin-top:6px"><button id="closeInfo" style="padding:6px 8px; border-radius:5px; border:none; background:#222; color:#fff; cursor:pointer">Close</button></div>
    `;
    showInfoScreen(ev.clientX + 6, ev.clientY + 6, html);
    const btn = document.getElementById('closeInfo');
    if (btn) btn.onclick = hideInfoScreen;
  } else {
    hideInfoScreen();
  }
}

/* ---------- Animation loop (twinkle time + earth rotation) ---------- */
const clock = new THREE.Clock();
let locatingUser = true;
let userLocationFound = false;
let rotateToUser = false;
let targetQuat = new THREE.Quaternion();

function latLonToVec3(lat, lon, radius) {
  const latRad = THREE.MathUtils.degToRad(lat);
  const lonRad = THREE.MathUtils.degToRad(lon);
  const x = radius * Math.cos(latRad) * Math.cos(lonRad);
  const y = radius * Math.sin(latRad);
  const z = radius * Math.cos(latRad) * Math.sin(lonRad);
  return new THREE.Vector3(x, y, z);
}

function setUserLocation(lat, lon) {
  const point = latLonToVec3(lat, lon, EARTH_R + 0.22);
  userMarker.position.copy(point);
  userMarker.visible = true;
  userLocationFound = true;
  locatingUser = false;

  const currentWorldPos = point.clone().applyQuaternion(earthGroup.quaternion);
  const desiredDir = new THREE.Vector3(0, 0, 1);
  const deltaQuat = new THREE.Quaternion().setFromUnitVectors(currentWorldPos.clone().normalize(), desiredDir);
  targetQuat = deltaQuat.multiply(earthGroup.quaternion.clone());
  rotateToUser = true;
  STATUS.textContent = 'Location found. Centering your pin...';
}

function requestUserLocation() {
  if (!navigator.geolocation) {
    locatingUser = false;
    STATUS.textContent = 'Geolocation unavailable. Rotate Earth manually.';
    return;
  }

  STATUS.textContent = 'Locating your position...';
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      setUserLocation(pos.coords.latitude, pos.coords.longitude);
    },
    () => {
      locatingUser = false;
      STATUS.textContent = 'Location denied/unavailable. Rotate Earth manually.';
    },
    { enableHighAccuracy: true, timeout: 12000, maximumAge: 120000 }
  );
}

requestUserLocation();

function animate() {
  requestAnimationFrame(animate);
  clock.getElapsedTime();

  if (locatingUser) {
    earthGroup.rotation.y += 0.0011;
    setProcess('Rotating Earth while locating you...');
  }

  if (rotateToUser) {
    earthGroup.quaternion.slerp(targetQuat, 0.018);
    if (earthGroup.quaternion.angleTo(targetQuat) < 0.01) {
      earthGroup.quaternion.copy(targetQuat);
      rotateToUser = false;
      STATUS.textContent = userLocationFound ? 'Your location is pinned.' : STATUS.textContent;
      setProcess(userLocationFound ? 'Tracking ready. You can rotate Earth.' : currentProcessText);
    }
  }

  if (locatingUser) {
    earthGroup.rotation.y += 0.0022;
  }

  if (rotateToUser) {
    earthGroup.quaternion.slerp(targetQuat, 0.03);
    if (earthGroup.quaternion.angleTo(targetQuat) < 0.01) {
      earthGroup.quaternion.copy(targetQuat);
      rotateToUser = false;
      STATUS.textContent = userLocationFound ? 'Your location is pinned.' : STATUS.textContent;
    }
  }

  // gentle Earth rotation (visual)
  if (!locatingUser && !rotateToUser) earthGroup.rotation.y += 0.00025;
  // gentle sky rotation opposite a bit to suggest parallax
  skyGroup.rotation.y -= 0.0001;

  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();

/* ---------- Resize handling ---------- */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  labelRenderer.setSize(window.innerWidth, window.innerHeight);
});

/* ---------- Prevent zoom (pinch) on mobile by blocking wheel & touch gestures that change camera zoom ---------------- */
window.addEventListener('wheel', (e) => { if (Math.abs(e.deltaY) > 0) e.preventDefault(); }, { passive: false });
/* pointer gestures are handled by controls; since zoom disabled, pinch won't zoom. */

</script>
</body>
  </html>
